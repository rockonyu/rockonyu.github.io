<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A statically generated blog example using Next.js and Markdown."/><meta property="og:image" content="https://og-image.now.sh/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>JS Ninja: 2. First-Class Function | Austin&#x27;s Blog</title><meta property="og:image"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/393dc2aa74ed7dc8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/393dc2aa74ed7dc8.css" data-n-g=""/><link rel="preload" href="/_next/static/css/1c297baedac28db3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1c297baedac28db3.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-a5f2beb8b3d215d7.js" defer=""></script><script src="/_next/static/chunks/pages/_app-57f97a3cc8323c9b.js" defer=""></script><script src="/_next/static/chunks/912-b70cd8456d4a2e3a.js" defer=""></script><script src="/_next/static/chunks/7-1c92f304826421cc.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-ebbc1958adf2fc2c.js" defer=""></script><script src="/_next/static/4dY-zI4L3O2rMAQgNcicC/_buildManifest.js" defer=""></script><script src="/_next/static/4dY-zI4L3O2rMAQgNcicC/_ssgManifest.js" defer=""></script><script src="/_next/static/4dY-zI4L3O2rMAQgNcicC/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/">Blog</a>.</h2><article class="mb-32"><h1 class="text-6xl md:text-7xl lg:text-8xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center md:text-left">JS Ninja: 2. First-Class Function</h1><div class="max-w-2xl mx-auto"><div class="mb-6 text-lg"><time dateTime="2020-07-11T00:00:00.000Z">2020/07/11</time></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__1x9gM"><p>簡單的筆記與紀錄額外參考，原作：忍者：JavaScript  開發技巧探秘</p>
<h2>CH3 - 初探頭等函式：定義與引數</h2>
<h3>3.1 使用函式與否的差異為何？</h3>
<p>JavaScript 中物件與函式有以下特性：</p>
<ul>
<li>透過實值 (literal) 建立</li>
<li>指派給變數、陣列資料與其他物件的屬性</li>
<li>作為引數傳遞給函式</li>
<li>可以做為函式的回傳值</li>
<li>擁有可動態建立和指派的屬性</li>
</ul>
<p>頭等函式的其中一個特性是可以作為引數傳遞給函式。</p>
<p>回呼函式是設置一個預備在稍後呼叫的函式，藉由瀏覽器在事件處理階段或透過其他程式碼。</p>
<p>JavaScript  最重要的特性之一是能夠在程式的任何地方建立函式，使程式碼更緊湊易理解，還可以避免全域命名空間被汙染 (例如箭頭函式)。</p>
<p>ex. 使用比對器進行排序，不需要考慮排序演算法的細節：</p>
<pre><code>var values = [0, 3, 2, 5, 7, 4, 8, 1]

values.sort(function (values, values) {
  return value1 - value2
})
</code></pre>
<h3>3.2 函式作為物件的有趣之處</h3>
<p>我們將屬性附加到函式上，可以用來：</p>
<ul>
<li>儲存函式</li>
</ul>
<pre><code>var store = {
  nextId: 1,
  cache: {},
  add: function (fn) {
    if (!fn.id) {
      fn.id = this.nextId++
      this.cache[fn.id] = fn
      return true
    }
  },
}
function ninja() {}

assert(store.add(ninja), 'Function was safely added.')
assert(!store.add(ninja), 'But it was only added once.')
</code></pre>
<ul>
<li>自我記憶函式</li>
</ul>
<pre><code>function isPrime(value) {
  if (!isPrime.answers) {
    isPrime.answers = {}
  }

  if (isPrime.answers[value] !== undefined) {
    return isPrime.answers[value]
  }

  var prime = value !== 0 &#x26;&#x26; value !== 1

  for (var i = 2; i &#x3C; value; i++) {
    if (value % i === 0) {
      prime = false
      break
    }
  }
  return (isPrime.answers[value] = prime) // 儲存計算結果
}
</code></pre>
<p>pros:</p>
<ul>
<li>藉由取得之前計算的值改善呼叫函式的效能</li>
<li>背景作業，不需要執行特殊請求或額外初始化</li>
</ul>
<p>cons:</p>
<ul>
<li>任何形式的暫存都式花費記憶體空間換取效能</li>
<li>暫存不應該與業務邏輯綁在一起</li>
<li>很難對這樣的演算法進行負載測試或測量效能，因為結果取決於之前的輸入</li>
</ul>
<h3>3.3 定義函式</h3>
<ul>
<li>函式宣告 (declaration) 與函式表達式 (expression)</li>
<li>箭頭函式</li>
<li>函式建構式</li>
<li>生成器 (generator)</li>
</ul>
<pre><code>// 獨立函式宣告
function myFunctionDeclaration() {
  // 內部函式宣告
  function innerFunction() {}
}

// 函式表達式與變數宣告 &#x26; 指派
var myFunc = function () {}
// 函式表達式作為回呼引數
myFunc(function () {
  // 函式表達式作為回傳值
  return function () {}
})

// 具名的函式表達式做為立即函式的一部分
;(function namedFunctionExpression() {})()

// 作為一元運作子的引數而被立即呼叫的函式表達式
;+(function () {})()
;-(function () {})()
!(function () {})()
~(function () {})()
</code></pre>
<p>立即函式 (IIFE)</p>
<pre><code>;(function () {})(3)
</code></pre>
<p>箭頭函式</p>
<ul>
<li>param => expression</li>
<li>主體如果只有表達式，即是函式的回傳值</li>
<li>如果沒有 return 敘述句，呼叫的結果是 undefined</li>
</ul>
<pre><code>var values = [0, 3, 2, 5, 7, 4, 8, 1]
values.sort((value1, value2) => value1 - value2)
</code></pre>
<h3>3.4 引數 (argument) 與函式參數 (parameter)</h3>
<pre><code>// 函式參數
function skulk(ninja) {
  // 函式引數
  return performAction(ninja, 'skulking')
}
</code></pre>
<p>使用不定參數</p>
<ul>
<li>需要放在最後一個函式參數，否則會得到 Syntax Error</li>
</ul>
<pre><code>function multiMax(first, ...remainingNumbers) {
  var sorted = remainingNumbers.sort(function (a, b) {
    return b - a
  })
  return first * sorted[0]
}
</code></pre>
<ul>
<li>使用預設參數</li>
</ul>
<pre><code>function performAction(ninja, action = 'skulking') {
  return ninja + ' ' + action
}
</code></pre>
<h3>3.5 總結</h3>
<h3>補充參考</h3>
<ul>
<li><a href="https://www.notion.so/Chapter3-df2158c43739481bafbf6a1b43709d70">阿福的筆記</a></li>
<li><a href="https://www.coderbridge.com/@waynelee2048/a58346d15d2f4100ae6eebd8ed34aff3">阿寬的筆記</a></li>
</ul>
</div></div></article></div></main></div><footer class="bg-accent-1 border-t border-accent-2"><div class="container mx-auto px-5"><div class="py-28 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-5xl font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4">Statically Generated with Next.js.</h3></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"JS Ninja: 2. First-Class Function","date":"2020-07-11T00:00:00.000Z","slug":"2020/js-ninja-2-first-class-function","content":"\u003cp\u003e簡單的筆記與紀錄額外參考，原作：忍者：JavaScript  開發技巧探秘\u003c/p\u003e\n\u003ch2\u003eCH3 - 初探頭等函式：定義與引數\u003c/h2\u003e\n\u003ch3\u003e3.1 使用函式與否的差異為何？\u003c/h3\u003e\n\u003cp\u003eJavaScript 中物件與函式有以下特性：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e透過實值 (literal) 建立\u003c/li\u003e\n\u003cli\u003e指派給變數、陣列資料與其他物件的屬性\u003c/li\u003e\n\u003cli\u003e作為引數傳遞給函式\u003c/li\u003e\n\u003cli\u003e可以做為函式的回傳值\u003c/li\u003e\n\u003cli\u003e擁有可動態建立和指派的屬性\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e頭等函式的其中一個特性是可以作為引數傳遞給函式。\u003c/p\u003e\n\u003cp\u003e回呼函式是設置一個預備在稍後呼叫的函式，藉由瀏覽器在事件處理階段或透過其他程式碼。\u003c/p\u003e\n\u003cp\u003eJavaScript  最重要的特性之一是能夠在程式的任何地方建立函式，使程式碼更緊湊易理解，還可以避免全域命名空間被汙染 (例如箭頭函式)。\u003c/p\u003e\n\u003cp\u003eex. 使用比對器進行排序，不需要考慮排序演算法的細節：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar values = [0, 3, 2, 5, 7, 4, 8, 1]\n\nvalues.sort(function (values, values) {\n  return value1 - value2\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3.2 函式作為物件的有趣之處\u003c/h3\u003e\n\u003cp\u003e我們將屬性附加到函式上，可以用來：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e儲存函式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003evar store = {\n  nextId: 1,\n  cache: {},\n  add: function (fn) {\n    if (!fn.id) {\n      fn.id = this.nextId++\n      this.cache[fn.id] = fn\n      return true\n    }\n  },\n}\nfunction ninja() {}\n\nassert(store.add(ninja), 'Function was safely added.')\nassert(!store.add(ninja), 'But it was only added once.')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e自我記憶函式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003efunction isPrime(value) {\n  if (!isPrime.answers) {\n    isPrime.answers = {}\n  }\n\n  if (isPrime.answers[value] !== undefined) {\n    return isPrime.answers[value]\n  }\n\n  var prime = value !== 0 \u0026#x26;\u0026#x26; value !== 1\n\n  for (var i = 2; i \u0026#x3C; value; i++) {\n    if (value % i === 0) {\n      prime = false\n      break\n    }\n  }\n  return (isPrime.answers[value] = prime) // 儲存計算結果\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epros:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e藉由取得之前計算的值改善呼叫函式的效能\u003c/li\u003e\n\u003cli\u003e背景作業，不需要執行特殊請求或額外初始化\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003econs:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e任何形式的暫存都式花費記憶體空間換取效能\u003c/li\u003e\n\u003cli\u003e暫存不應該與業務邏輯綁在一起\u003c/li\u003e\n\u003cli\u003e很難對這樣的演算法進行負載測試或測量效能，因為結果取決於之前的輸入\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e3.3 定義函式\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e函式宣告 (declaration) 與函式表達式 (expression)\u003c/li\u003e\n\u003cli\u003e箭頭函式\u003c/li\u003e\n\u003cli\u003e函式建構式\u003c/li\u003e\n\u003cli\u003e生成器 (generator)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003e// 獨立函式宣告\nfunction myFunctionDeclaration() {\n  // 內部函式宣告\n  function innerFunction() {}\n}\n\n// 函式表達式與變數宣告 \u0026#x26; 指派\nvar myFunc = function () {}\n// 函式表達式作為回呼引數\nmyFunc(function () {\n  // 函式表達式作為回傳值\n  return function () {}\n})\n\n// 具名的函式表達式做為立即函式的一部分\n;(function namedFunctionExpression() {})()\n\n// 作為一元運作子的引數而被立即呼叫的函式表達式\n;+(function () {})()\n;-(function () {})()\n!(function () {})()\n~(function () {})()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e立即函式 (IIFE)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e;(function () {})(3)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e箭頭函式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eparam =\u003e expression\u003c/li\u003e\n\u003cli\u003e主體如果只有表達式，即是函式的回傳值\u003c/li\u003e\n\u003cli\u003e如果沒有 return 敘述句，呼叫的結果是 undefined\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003evar values = [0, 3, 2, 5, 7, 4, 8, 1]\nvalues.sort((value1, value2) =\u003e value1 - value2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3.4 引數 (argument) 與函式參數 (parameter)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e// 函式參數\nfunction skulk(ninja) {\n  // 函式引數\n  return performAction(ninja, 'skulking')\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用不定參數\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e需要放在最後一個函式參數，否則會得到 Syntax Error\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003efunction multiMax(first, ...remainingNumbers) {\n  var sorted = remainingNumbers.sort(function (a, b) {\n    return b - a\n  })\n  return first * sorted[0]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e使用預設參數\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003efunction performAction(ninja, action = 'skulking') {\n  return ninja + ' ' + action\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3.5 總結\u003c/h3\u003e\n\u003ch3\u003e補充參考\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.notion.so/Chapter3-df2158c43739481bafbf6a1b43709d70\"\u003e阿福的筆記\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.coderbridge.com/@waynelee2048/a58346d15d2f4100ae6eebd8ed34aff3\"\u003e阿寬的筆記\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["2020","js-ninja-2-first-class-function"]},"buildId":"4dY-zI4L3O2rMAQgNcicC","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>