<!DOCTYPE html><html lang="en" class="dark"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A statically generated blog example using Next.js and Blog."/><meta property="og:image" content="https://og-image.now.sh/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>為什麼我的請求總是被快取!? | Austin&#x27;s Blog</title><meta property="og:image"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/36ffbeb137063984.css" as="style"/><link rel="stylesheet" href="/_next/static/css/36ffbeb137063984.css" data-n-g=""/><link rel="preload" href="/_next/static/css/3487f9a18938f337.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3487f9a18938f337.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-01df828e572375b9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-76cd57bf65f05d70.js" defer=""></script><script src="/_next/static/chunks/740-91d59e11f93e1060.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-e3635f87d2450c91.js" defer=""></script><script src="/_next/static/d8V0JT4WbFbUqT_-Q01ia/_buildManifest.js" defer=""></script><script src="/_next/static/d8V0JT4WbFbUqT_-Q01ia/_ssgManifest.js" defer=""></script><script src="/_next/static/d8V0JT4WbFbUqT_-Q01ia/_middlewareManifest.js" defer=""></script></head><body class="dark:bg-accent-9 dark:text-white"><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/">Blog</a>.</h2><article class="mb-16"><h1 class="text-6xl md:text-7xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center md:text-left">為什麼我的請求總是被快取!?</h1><div class="max-w-2xl mx-auto"><div class="mb-6 text-lg"><time dateTime="2022-11-04T08:03:33Z">11/4/2022, 8:03:33 AM</time></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__8Ahqd mb-16"><p>過去兩年一直有個待解的問題：在新的版本上線後，多語系檔案有時會被瀏覽器快取。前同事曾經有試著修正，但因為不是每次部署後都會發生，加上目前客戶不多，通常遇到問題時都是請 QA 手動清掉快取。</p>
<p>這週在閱讀快取相關文件時，意外發現這個問題發生的原因與解法，透過此篇文章記錄。</p>
<h1 id="情境">情境<a aria-hidden="true" tabindex="-1" href="#情境"><span>#</span></a></h1>
<p>網站是透過 nginx 提供靜態資源的 Etag 與 Last-Modified 標頭，在不考慮瀏覽器端快取的情境，收到回應後的下次請求需要將 If-None-Match 或 If-Modified-Since 帶在標頭，伺服器端才有機會透過 hash 判斷回應 200 新資源或 304 沿用舊資源。</p>
<p>我們的情境是請求常常遺漏了 If-None-Match 或 If-Modified-Since 標頭，回應也不是預期中的 304。</p>
<h1 id="研究">研究<a aria-hidden="true" tabindex="-1" href="#研究"><span>#</span></a></h1>
<p>很好奇為什麼請求遺漏了 If-None-Match，找到這篇 <a href="https://stackoverflow.com/questions/15900548/why-browser-does-not-send-if-none-match-header">文章</a> 提到 gzip 可能會造成 Etag 計算差異，才不回應 304，但將 gzip 相關設定都移除後問題仍在。</p>
<p>再者也懷疑前端 CRA 請求資源時移除了相關的欄位，但沒發現有類似 issue，反而這篇快取設定的 <a href="https://create-react-app.dev/docs/production-build/#static-file-caching">文章</a> 有提到一些關鍵，內文建議除了 static 資料夾以外的資源都設定成 <code>Cache-Control: no-cache</code>，當下是認為有 Etag 這邊應該不用另外調整。</p>
<p>經過一段時間如無頭蒼蠅般的搜尋後，決定重看 MDN 在於快取方面的介紹，結果在前幾個段落就發現一個沒看過的名詞：heuristic caching。</p>
<h1 id="heuristic-caching">Heuristic caching<a aria-hidden="true" tabindex="-1" href="#heuristic-caching"><span>#</span></a></h1>
<blockquote>
<p>HTTP 被設計成盡可能的快取任何資源，即使沒有提供 Cache-Control 標頭，在特定條件成立時資源仍然會被快取。</p>
</blockquote>
<p>特定條件指的是在僅設定 Date 與 Last Modified 的情境。</p>
<p>例如 Last-Modified 時間是一年前，瀏覽器猜測這份資源不會這麼快被變更而將其快取，實際客戶端的快取時間由瀏覽器的實作決定，規格建議是上次修改時間的 1/10，以剛剛的例子來說就是在 36.5 天後，才會實際發出 API 到伺服器端確認資源是否過期。</p>
<p>檢查網站的回應確實沒有提供 Cache-Control 標頭，這樣會造成瀏覽器認定此份資源仍然有效，連請求都沒有發出去，當然也就無從收到伺服器回應的 304。</p>
<p>因此先依照 CRA 文件的建議在 nginx 將 static 資料夾以外的 HTTP 回應都加上 <code>Cache-Control: no-cache</code> 標頭，在確認回應同時有 Cache-Control 與 Etag 標頭的情況，就正常的將其帶入下次請求的標頭，也取得預期中的 304 回應。</p>
<h1 id="學習到什麼">學習到什麼<a aria-hidden="true" tabindex="-1" href="#學習到什麼"><span>#</span></a></h1>
<ol>
<li>Etag、Last Modified 盡量不要單獨使用，回應都盡量要加上 Cache-Control 標頭</li>
<li>回應只有 Date 與 Last Modified 會讓瀏覽器進入 heuristic caching，無法控制資源要被更新的時機</li>
</ol>
<ul>
<li>https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#heuristic_caching</li>
<li>https://blog.techbridge.cc/2017/06/17/cache-introduction/</li>
<li>https://www.kabisa.nl/tech/http-caching-gotcha-heuristic-freshness/</li>
<li>https://blog.csdn.net/qq_34556414/article/details/106337292</li>
</ul></div><div id="disqus_thread"></div></div></article></div></main></div><footer class="bg-accent-1 border-t border-accent-2 dark:bg-accent-8"><div class="container mx-auto px-5"><div class="py-16 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-5xl font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4"></h3></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"為什麼我的請求總是被快取!?","date":"2022-11-04T08:03:33Z","slug":"2022/heuristic-caching","content":"\u003cp\u003e過去兩年一直有個待解的問題：在新的版本上線後，多語系檔案有時會被瀏覽器快取。前同事曾經有試著修正，但因為不是每次部署後都會發生，加上目前客戶不多，通常遇到問題時都是請 QA 手動清掉快取。\u003c/p\u003e\n\u003cp\u003e這週在閱讀快取相關文件時，意外發現這個問題發生的原因與解法，透過此篇文章記錄。\u003c/p\u003e\n\u003ch1 id=\"情境\"\u003e情境\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#情境\"\u003e\u003cspan\u003e#\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e網站是透過 nginx 提供靜態資源的 Etag 與 Last-Modified 標頭，在不考慮瀏覽器端快取的情境，收到回應後的下次請求需要將 If-None-Match 或 If-Modified-Since 帶在標頭，伺服器端才有機會透過 hash 判斷回應 200 新資源或 304 沿用舊資源。\u003c/p\u003e\n\u003cp\u003e我們的情境是請求常常遺漏了 If-None-Match 或 If-Modified-Since 標頭，回應也不是預期中的 304。\u003c/p\u003e\n\u003ch1 id=\"研究\"\u003e研究\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#研究\"\u003e\u003cspan\u003e#\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e很好奇為什麼請求遺漏了 If-None-Match，找到這篇 \u003ca href=\"https://stackoverflow.com/questions/15900548/why-browser-does-not-send-if-none-match-header\"\u003e文章\u003c/a\u003e 提到 gzip 可能會造成 Etag 計算差異，才不回應 304，但將 gzip 相關設定都移除後問題仍在。\u003c/p\u003e\n\u003cp\u003e再者也懷疑前端 CRA 請求資源時移除了相關的欄位，但沒發現有類似 issue，反而這篇快取設定的 \u003ca href=\"https://create-react-app.dev/docs/production-build/#static-file-caching\"\u003e文章\u003c/a\u003e 有提到一些關鍵，內文建議除了 static 資料夾以外的資源都設定成 \u003ccode\u003eCache-Control: no-cache\u003c/code\u003e，當下是認為有 Etag 這邊應該不用另外調整。\u003c/p\u003e\n\u003cp\u003e經過一段時間如無頭蒼蠅般的搜尋後，決定重看 MDN 在於快取方面的介紹，結果在前幾個段落就發現一個沒看過的名詞：heuristic caching。\u003c/p\u003e\n\u003ch1 id=\"heuristic-caching\"\u003eHeuristic caching\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#heuristic-caching\"\u003e\u003cspan\u003e#\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHTTP 被設計成盡可能的快取任何資源，即使沒有提供 Cache-Control 標頭，在特定條件成立時資源仍然會被快取。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e特定條件指的是在僅設定 Date 與 Last Modified 的情境。\u003c/p\u003e\n\u003cp\u003e例如 Last-Modified 時間是一年前，瀏覽器猜測這份資源不會這麼快被變更而將其快取，實際客戶端的快取時間由瀏覽器的實作決定，規格建議是上次修改時間的 1/10，以剛剛的例子來說就是在 36.5 天後，才會實際發出 API 到伺服器端確認資源是否過期。\u003c/p\u003e\n\u003cp\u003e檢查網站的回應確實沒有提供 Cache-Control 標頭，這樣會造成瀏覽器認定此份資源仍然有效，連請求都沒有發出去，當然也就無從收到伺服器回應的 304。\u003c/p\u003e\n\u003cp\u003e因此先依照 CRA 文件的建議在 nginx 將 static 資料夾以外的 HTTP 回應都加上 \u003ccode\u003eCache-Control: no-cache\u003c/code\u003e 標頭，在確認回應同時有 Cache-Control 與 Etag 標頭的情況，就正常的將其帶入下次請求的標頭，也取得預期中的 304 回應。\u003c/p\u003e\n\u003ch1 id=\"學習到什麼\"\u003e學習到什麼\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#學習到什麼\"\u003e\u003cspan\u003e#\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eEtag、Last Modified 盡量不要單獨使用，回應都盡量要加上 Cache-Control 標頭\u003c/li\u003e\n\u003cli\u003e回應只有 Date 與 Last Modified 會讓瀏覽器進入 heuristic caching，無法控制資源要被更新的時機\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003ehttps://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#heuristic_caching\u003c/li\u003e\n\u003cli\u003ehttps://blog.techbridge.cc/2017/06/17/cache-introduction/\u003c/li\u003e\n\u003cli\u003ehttps://www.kabisa.nl/tech/http-caching-gotcha-heuristic-freshness/\u003c/li\u003e\n\u003cli\u003ehttps://blog.csdn.net/qq_34556414/article/details/106337292\u003c/li\u003e\n\u003c/ul\u003e"}},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["2022","heuristic-caching"]},"buildId":"d8V0JT4WbFbUqT_-Q01ia","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>