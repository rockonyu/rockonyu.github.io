<!DOCTYPE html><html lang="en" class="dark"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A statically generated blog example using Next.js and Blog."/><meta property="og:image" content="https://og-image.now.sh/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>為什麼我的請求總是被快取!? | Austin&#x27;s Blog</title><meta property="og:image"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/36ffbeb137063984.css" as="style"/><link rel="stylesheet" href="/_next/static/css/36ffbeb137063984.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e53b81a0fc02a481.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e53b81a0fc02a481.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-01df828e572375b9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-76cd57bf65f05d70.js" defer=""></script><script src="/_next/static/chunks/740-91d59e11f93e1060.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-e3635f87d2450c91.js" defer=""></script><script src="/_next/static/wBQEFwPKtOMMH6eeT89Q_/_buildManifest.js" defer=""></script><script src="/_next/static/wBQEFwPKtOMMH6eeT89Q_/_ssgManifest.js" defer=""></script><script src="/_next/static/wBQEFwPKtOMMH6eeT89Q_/_middlewareManifest.js" defer=""></script></head><body class="dark:bg-accent-9 dark:text-white"><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/">Blog</a>.</h2><article class="mb-16"><h1 class="text-6xl md:text-7xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center md:text-left">為什麼我的請求總是被快取!?</h1><div class="max-w-2xl mx-auto"><div class="mb-6 text-lg"><time dateTime="2022-11-04T08:03:33Z">11/4/2022, 8:03:33 AM</time></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__8Ahqd mb-16"><p>目前開發的產品是 SPA 架構，但過去兩年一直有個待解的問題，在發佈新版後偶爾會有資源沒更新到 (ex. 多語系檔案)。曾經有試著調整，但因為不是每次都會發生，加上目前客戶不多，問題常常被掩蓋著。</p>
<p>此次花時間研究 nginx 跟瀏覽器關於快取的標頭，最後解法卻意外的簡單，用此篇文章記錄過程中走歪的路。</p>
<h2 id="情境">情境<a aria-hidden="true" tabindex="-1" href="#情境"><span>#</span></a></h2>
<p>我們透過 nginx 提供靜態資源的 Etag 與 Last-Modified，在先不考慮瀏覽器端快取的情境，一般來說收到回應的下次請求需要將 If-None-Match 或 If-Modified-Since 帶在標頭，伺服器端才有機會透過 hash 判斷回應 200 新資源或 304 沿用舊資源。</p>
<p>在我們網站的情境是，初次回應明明有帶特定標頭，但後續的請求卻沒有將其帶回來，也沒有收到預期中的 304。</p>
<h2 id="研究">研究<a aria-hidden="true" tabindex="-1" href="#研究"><span>#</span></a></h2>
<p>一開始朝向為什麼請求沒有帶 If-None-Match，找到這篇 <a href="https://stackoverflow.com/questions/15900548/why-browser-does-not-send-if-none-match-header">文章</a>，在想是否因為 gzip 造成 Etag 不同才不會回應 304，但將相關設定都移除後問題仍在。</p>
<p>再者也懷疑在前端 CRA 請求資源時移除了相關的欄位，有去找看是否有人遇到類似 issue，這篇快取設定的 <a href="https://create-react-app.dev/docs/production-build/#static-file-caching">文章</a> 其實有提到一些關鍵，內文建議，除了 static 資料夾以外的資源都可以設定成 <code>Cache-Control: no-cache</code>，當下是認為設定了 Etag 這邊應該不用另外調整。</p>
<p>花了些時間如無頭蒼蠅般的搜尋後，因為也想不到其他更好的方式，決定重看 MDN 在於快取方面的介紹，結果在前幾個段落就發現一個沒看過的名詞：heuristic caching。</p>
<h1 id="heuristic-caching">Heuristic caching<a aria-hidden="true" tabindex="-1" href="#heuristic-caching"><span>#</span></a></h1>
<blockquote>
<p>HTTP 被設計成盡可能的快取任何資源，即使沒有提供 Cache-Control 標頭，在特定條件成立時資源仍然會被快取。</p>
</blockquote>
<p>這個特定條件就是在只設定了 Date 與 Last Modified 的情境。</p>
<p>例如 Last-Modified 時間是一年前，瀏覽器會預期這份資源不會這麼快被變更，因此會將其快取，實際時間由瀏覽器的實作決定，MDN 裡提到規格建議是 1/10 的時間，例如在沒有手動清除快取的情境下，會在 36.5 天後才會實際打出 API 到伺服器端確認資源是否過期。</p>
<p>回頭檢查我們網站的回應，確實只有 Etag、Last Modified 與 Date，認定就是進入了 heuristic caching，才會無法完整控制快取的行為。</p>
<p>有點不是很確定，但猜測幫回應加上 Etag、Last Modified 與 Date 是 nginx 的預設行為，最後就先依照 CRA 文件建議將 static 資料夾以外的 HTTP 回應加上 <code>Cache-Control: no-cache</code> 標頭。</p>
<p>確認瀏覽器在有 Cache-Control 與 Etag 相互配合的情況，終於將 If-None-Match 帶入下次請求的標頭，也取得預期中的 304 回應了。</p>
<h1 id="學習到什麼">學習到什麼<a aria-hidden="true" tabindex="-1" href="#學習到什麼"><span>#</span></a></h1>
<ol>
<li>Etag、Last Modified 需要與 Cache-Control 搭配使用</li>
<li>僅有 Last Modified 與 Date 會進入 heuristic caching，由瀏覽器決定快取時間</li>
</ol>
<ul>
<li>https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#heuristic_caching</li>
<li>https://blog.techbridge.cc/2017/06/17/cache-introduction/</li>
<li>https://www.kabisa.nl/tech/http-caching-gotcha-heuristic-freshness/</li>
</ul></div><div id="disqus_thread"></div></div></article></div></main></div><footer class="bg-accent-1 border-t border-accent-2 dark:bg-accent-8"><div class="container mx-auto px-5"><div class="py-16 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-5xl font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4"></h3></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"為什麼我的請求總是被快取!?","date":"2022-11-04T08:03:33Z","slug":"2022/heuristic-caching","content":"\u003cp\u003e目前開發的產品是 SPA 架構，但過去兩年一直有個待解的問題，在發佈新版後偶爾會有資源沒更新到 (ex. 多語系檔案)。曾經有試著調整，但因為不是每次都會發生，加上目前客戶不多，問題常常被掩蓋著。\u003c/p\u003e\n\u003cp\u003e此次花時間研究 nginx 跟瀏覽器關於快取的標頭，最後解法卻意外的簡單，用此篇文章記錄過程中走歪的路。\u003c/p\u003e\n\u003ch2 id=\"情境\"\u003e情境\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#情境\"\u003e\u003cspan\u003e#\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e我們透過 nginx 提供靜態資源的 Etag 與 Last-Modified，在先不考慮瀏覽器端快取的情境，一般來說收到回應的下次請求需要將 If-None-Match 或 If-Modified-Since 帶在標頭，伺服器端才有機會透過 hash 判斷回應 200 新資源或 304 沿用舊資源。\u003c/p\u003e\n\u003cp\u003e在我們網站的情境是，初次回應明明有帶特定標頭，但後續的請求卻沒有將其帶回來，也沒有收到預期中的 304。\u003c/p\u003e\n\u003ch2 id=\"研究\"\u003e研究\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#研究\"\u003e\u003cspan\u003e#\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e一開始朝向為什麼請求沒有帶 If-None-Match，找到這篇 \u003ca href=\"https://stackoverflow.com/questions/15900548/why-browser-does-not-send-if-none-match-header\"\u003e文章\u003c/a\u003e，在想是否因為 gzip 造成 Etag 不同才不會回應 304，但將相關設定都移除後問題仍在。\u003c/p\u003e\n\u003cp\u003e再者也懷疑在前端 CRA 請求資源時移除了相關的欄位，有去找看是否有人遇到類似 issue，這篇快取設定的 \u003ca href=\"https://create-react-app.dev/docs/production-build/#static-file-caching\"\u003e文章\u003c/a\u003e 其實有提到一些關鍵，內文建議，除了 static 資料夾以外的資源都可以設定成 \u003ccode\u003eCache-Control: no-cache\u003c/code\u003e，當下是認為設定了 Etag 這邊應該不用另外調整。\u003c/p\u003e\n\u003cp\u003e花了些時間如無頭蒼蠅般的搜尋後，因為也想不到其他更好的方式，決定重看 MDN 在於快取方面的介紹，結果在前幾個段落就發現一個沒看過的名詞：heuristic caching。\u003c/p\u003e\n\u003ch1 id=\"heuristic-caching\"\u003eHeuristic caching\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#heuristic-caching\"\u003e\u003cspan\u003e#\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHTTP 被設計成盡可能的快取任何資源，即使沒有提供 Cache-Control 標頭，在特定條件成立時資源仍然會被快取。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e這個特定條件就是在只設定了 Date 與 Last Modified 的情境。\u003c/p\u003e\n\u003cp\u003e例如 Last-Modified 時間是一年前，瀏覽器會預期這份資源不會這麼快被變更，因此會將其快取，實際時間由瀏覽器的實作決定，MDN 裡提到規格建議是 1/10 的時間，例如在沒有手動清除快取的情境下，會在 36.5 天後才會實際打出 API 到伺服器端確認資源是否過期。\u003c/p\u003e\n\u003cp\u003e回頭檢查我們網站的回應，確實只有 Etag、Last Modified 與 Date，認定就是進入了 heuristic caching，才會無法完整控制快取的行為。\u003c/p\u003e\n\u003cp\u003e有點不是很確定，但猜測幫回應加上 Etag、Last Modified 與 Date 是 nginx 的預設行為，最後就先依照 CRA 文件建議將 static 資料夾以外的 HTTP 回應加上 \u003ccode\u003eCache-Control: no-cache\u003c/code\u003e 標頭。\u003c/p\u003e\n\u003cp\u003e確認瀏覽器在有 Cache-Control 與 Etag 相互配合的情況，終於將 If-None-Match 帶入下次請求的標頭，也取得預期中的 304 回應了。\u003c/p\u003e\n\u003ch1 id=\"學習到什麼\"\u003e學習到什麼\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#學習到什麼\"\u003e\u003cspan\u003e#\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eEtag、Last Modified 需要與 Cache-Control 搭配使用\u003c/li\u003e\n\u003cli\u003e僅有 Last Modified 與 Date 會進入 heuristic caching，由瀏覽器決定快取時間\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003ehttps://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#heuristic_caching\u003c/li\u003e\n\u003cli\u003ehttps://blog.techbridge.cc/2017/06/17/cache-introduction/\u003c/li\u003e\n\u003cli\u003ehttps://www.kabisa.nl/tech/http-caching-gotcha-heuristic-freshness/\u003c/li\u003e\n\u003c/ul\u003e"}},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["2022","heuristic-caching"]},"buildId":"wBQEFwPKtOMMH6eeT89Q_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>