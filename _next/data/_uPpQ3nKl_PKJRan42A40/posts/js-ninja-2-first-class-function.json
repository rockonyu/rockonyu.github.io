{"pageProps":{"post":{"title":"JS Ninja: 2. First-Class Function","date":"2020-07-11T00:00:00.000Z","slug":"js-ninja-2-first-class-function","content":"<p>簡單的筆記與紀錄額外參考，原作：<a href=\"https://www.books.com.tw/products/0010701459\" target=\"_blank\">忍者：JavaScript  開發技巧探秘</a></p>\n<h2>CH3 - 初探頭等函式：定義與引數</h2>\n<h3>3.1 使用函式與否的差異為何？</h3>\n<p>JavaScript 中物件與函式有以下特性：</p>\n<ul>\n<li>透過實值 (literal) 建立</li>\n<li>指派給變數、陣列資料與其他物件的屬性</li>\n<li>作為引數傳遞給函式</li>\n<li>可以做為函式的回傳值</li>\n<li>擁有可動態建立和指派的屬性</li>\n</ul>\n<p>頭等函式的其中一個特性是可以作為引數傳遞給函式。</p>\n<p>回呼函式是設置一個預備在稍後呼叫的函式，藉由瀏覽器在事件處理階段或透過其他程式碼。</p>\n<p>JavaScript  最重要的特性之一是能夠在程式的任何地方建立函式，使程式碼更緊湊易理解，還可以避免全域命名空間被汙染 (例如箭頭函式)。</p>\n<p>ex. 使用比對器進行排序，不需要考慮排序演算法的細節：</p>\n<pre><code class=\"language-javascript\">var values = [0, 3, 2, 5, 7, 4, 8, 1];\n\nvalues.sort(function (values, values) {\n  return value1 - value2;\n});\n</code></pre>\n<h3>3.2 函式作為物件的有趣之處</h3>\n<p>我們將屬性附加到函式上，可以用來：</p>\n<ul>\n<li>儲存函式</li>\n</ul>\n<pre><code class=\"language-javascript\">var store = {\n  nextId: 1,\n  cache: {},\n  add: function (fn) {\n    if (!fn.id) {\n      fn.id = this.nextId++;\n      this.cache[fn.id] = fn;\n      return true;\n    }\n  },\n};\nfunction ninja() {}\n\nassert(store.add(ninja), 'Function was safely added.');\nassert(!store.add(ninja), 'But it was only added once.');\n</code></pre>\n<ul>\n<li>自我記憶函式</li>\n</ul>\n<pre><code class=\"language-javascript\">function isPrime(value) {\n  if (!isPrime.answers) {\n    isPrime.answers = {};\n  }\n\n  if (isPrime.answers[value] !== undefined) {\n    return isPrime.answers[value];\n  }\n\n  var prime = value !== 0 &#x26;&#x26; value !== 1;\n\n  for (var i = 2; i &#x3C; value; i++) {\n    if (value % i === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return (isPrime.answers[value] = prime); // 儲存計算結果\n}\n</code></pre>\n<p>pros:</p>\n<ul>\n<li>藉由取得之前計算的值改善呼叫函式的效能</li>\n<li>背景作業，不需要執行特殊請求或額外初始化</li>\n</ul>\n<p>cons:</p>\n<ul>\n<li>任何形式的暫存都式花費記憶體空間換取效能</li>\n<li>暫存不應該與業務邏輯綁在一起</li>\n<li>很難對這樣的演算法進行負載測試或測量效能，因為結果取決於之前的輸入</li>\n</ul>\n<h3>3.3 定義函式</h3>\n<ul>\n<li>函式宣告 (declaration) 與函式表達式 (expression)</li>\n<li>箭頭函式</li>\n<li>函式建構式</li>\n<li>生成器 (generator)</li>\n</ul>\n<pre><code class=\"language-javascript\">// 獨立函式宣告\nfunction myFunctionDeclaration() {\n  // 內部函式宣告\n  function innerFunction() {}\n}\n\n// 函式表達式與變數宣告 &#x26; 指派\nvar myFunc = function () {};\n// 函式表達式作為回呼引數\nmyFunc(function () {\n  // 函式表達式作為回傳值\n  return function () {};\n});\n\n// 具名的函式表達式做為立即函式的一部分\n(function namedFunctionExpression() {})();\n\n// 作為一元運作子的引數而被立即呼叫的函式表達式\n+(function () {})();\n-(function () {})();\n!(function () {})();\n~(function () {})();\n</code></pre>\n<p>立即函式 (IIFE)</p>\n<pre><code class=\"language-javascript\">(function () {})(3);\n</code></pre>\n<p>箭頭函式</p>\n<ul>\n<li>param => expression</li>\n<li>主體如果只有表達式，即是函式的回傳值</li>\n<li>如果沒有 return 敘述句，呼叫的結果是 undefined</li>\n</ul>\n<pre><code class=\"language-javascript\">var values = [0, 3, 2, 5, 7, 4, 8, 1];\nvalues.sort((value1, value2) => value1 - value2);\n</code></pre>\n<h3>3.4 引數 (argument) 與函式參數 (parameter)</h3>\n<pre><code class=\"language-javascript\">// 函式參數\nfunction skulk(ninja) {\n  // 函式引數\n  return performAction(ninja, 'skulking');\n}\n</code></pre>\n<p>使用不定參數</p>\n<ul>\n<li>需要放在最後一個函式參數，否則會得到 Syntax Error</li>\n</ul>\n<pre><code class=\"language-javascript\">function multiMax(first, ...remainingNumbers) {\n  var sorted = remainingNumbers.sort(function (a, b) {\n    return b - a;\n  });\n  return first * sorted[0];\n}\n</code></pre>\n<ul>\n<li>使用預設參數</li>\n</ul>\n<pre><code class=\"language-javascript\">function performAction(ninja, action = 'skulking') {\n  return ninja + ' ' + action;\n}\n</code></pre>\n<h3>3.5 總結</h3>\n<h3>補充參考</h3>\n<ul>\n<li><a href=\"https://www.notion.so/Chapter3-df2158c43739481bafbf6a1b43709d70\">阿福的筆記</a></li>\n<li><a href=\"https://www.coderbridge.com/@waynelee2048/a58346d15d2f4100ae6eebd8ed34aff3\">阿寬的筆記</a></li>\n</ul>\n"}},"__N_SSG":true}