{"pageProps":{"post":{"title":"JS Ninja: 2. First-Class Function","date":"2020-07-11T00:00:00.000Z","slug":"2020/js-ninja-2-first-class-function","content":"<p>簡單的筆記與紀錄額外參考，原作：忍者：JavaScript  開發技巧探秘</p>\n<h2>CH3 - 初探頭等函式：定義與引數</h2>\n<h3>3.1 使用函式與否的差異為何？</h3>\n<p>JavaScript 中物件與函式有以下特性：</p>\n<ul>\n<li>透過實值 (literal) 建立</li>\n<li>指派給變數、陣列資料與其他物件的屬性</li>\n<li>作為引數傳遞給函式</li>\n<li>可以做為函式的回傳值</li>\n<li>擁有可動態建立和指派的屬性</li>\n</ul>\n<p>頭等函式的其中一個特性是可以作為引數傳遞給函式。</p>\n<p>回呼函式是設置一個預備在稍後呼叫的函式，藉由瀏覽器在事件處理階段或透過其他程式碼。</p>\n<p>JavaScript  最重要的特性之一是能夠在程式的任何地方建立函式，使程式碼更緊湊易理解，還可以避免全域命名空間被汙染 (例如箭頭函式)。</p>\n<p>ex. 使用比對器進行排序，不需要考慮排序演算法的細節：</p>\n<pre><code>var values = [0, 3, 2, 5, 7, 4, 8, 1]\n\nvalues.sort(function (values, values) {\n  return value1 - value2\n})\n</code></pre>\n<h3>3.2 函式作為物件的有趣之處</h3>\n<p>我們將屬性附加到函式上，可以用來：</p>\n<ul>\n<li>儲存函式</li>\n</ul>\n<pre><code>var store = {\n  nextId: 1,\n  cache: {},\n  add: function (fn) {\n    if (!fn.id) {\n      fn.id = this.nextId++\n      this.cache[fn.id] = fn\n      return true\n    }\n  },\n}\nfunction ninja() {}\n\nassert(store.add(ninja), 'Function was safely added.')\nassert(!store.add(ninja), 'But it was only added once.')\n</code></pre>\n<ul>\n<li>自我記憶函式</li>\n</ul>\n<pre><code>function isPrime(value) {\n  if (!isPrime.answers) {\n    isPrime.answers = {}\n  }\n\n  if (isPrime.answers[value] !== undefined) {\n    return isPrime.answers[value]\n  }\n\n  var prime = value !== 0 &#x26;&#x26; value !== 1\n\n  for (var i = 2; i &#x3C; value; i++) {\n    if (value % i === 0) {\n      prime = false\n      break\n    }\n  }\n  return (isPrime.answers[value] = prime) // 儲存計算結果\n}\n</code></pre>\n<p>pros:</p>\n<ul>\n<li>藉由取得之前計算的值改善呼叫函式的效能</li>\n<li>背景作業，不需要執行特殊請求或額外初始化</li>\n</ul>\n<p>cons:</p>\n<ul>\n<li>任何形式的暫存都式花費記憶體空間換取效能</li>\n<li>暫存不應該與業務邏輯綁在一起</li>\n<li>很難對這樣的演算法進行負載測試或測量效能，因為結果取決於之前的輸入</li>\n</ul>\n<h3>3.3 定義函式</h3>\n<ul>\n<li>函式宣告 (declaration) 與函式表達式 (expression)</li>\n<li>箭頭函式</li>\n<li>函式建構式</li>\n<li>生成器 (generator)</li>\n</ul>\n<pre><code>// 獨立函式宣告\nfunction myFunctionDeclaration() {\n  // 內部函式宣告\n  function innerFunction() {}\n}\n\n// 函式表達式與變數宣告 &#x26; 指派\nvar myFunc = function () {}\n// 函式表達式作為回呼引數\nmyFunc(function () {\n  // 函式表達式作為回傳值\n  return function () {}\n})\n\n// 具名的函式表達式做為立即函式的一部分\n;(function namedFunctionExpression() {})()\n\n// 作為一元運作子的引數而被立即呼叫的函式表達式\n;+(function () {})()\n;-(function () {})()\n!(function () {})()\n~(function () {})()\n</code></pre>\n<p>立即函式 (IIFE)</p>\n<pre><code>;(function () {})(3)\n</code></pre>\n<p>箭頭函式</p>\n<ul>\n<li>param => expression</li>\n<li>主體如果只有表達式，即是函式的回傳值</li>\n<li>如果沒有 return 敘述句，呼叫的結果是 undefined</li>\n</ul>\n<pre><code>var values = [0, 3, 2, 5, 7, 4, 8, 1]\nvalues.sort((value1, value2) => value1 - value2)\n</code></pre>\n<h3>3.4 引數 (argument) 與函式參數 (parameter)</h3>\n<pre><code>// 函式參數\nfunction skulk(ninja) {\n  // 函式引數\n  return performAction(ninja, 'skulking')\n}\n</code></pre>\n<p>使用不定參數</p>\n<ul>\n<li>需要放在最後一個函式參數，否則會得到 Syntax Error</li>\n</ul>\n<pre><code>function multiMax(first, ...remainingNumbers) {\n  var sorted = remainingNumbers.sort(function (a, b) {\n    return b - a\n  })\n  return first * sorted[0]\n}\n</code></pre>\n<ul>\n<li>使用預設參數</li>\n</ul>\n<pre><code>function performAction(ninja, action = 'skulking') {\n  return ninja + ' ' + action\n}\n</code></pre>\n<h3>3.5 總結</h3>\n<h3>補充參考</h3>\n<ul>\n<li><a href=\"https://www.notion.so/Chapter3-df2158c43739481bafbf6a1b43709d70\">阿福的筆記</a></li>\n<li><a href=\"https://www.coderbridge.com/@waynelee2048/a58346d15d2f4100ae6eebd8ed34aff3\">阿寬的筆記</a></li>\n</ul>\n"}},"__N_SSG":true}