{"pageProps":{"post":{"title":"JS 的亂數產生不重複","slug":"_deprecated/js-random","content":"<p>前幾天看到一個亂數產生不重複的寫法，覺得很有趣：</p>\n<pre><code class=\"hljs language-js\">[...<span class=\"hljs-title hljs-class\">Array</span>(<span class=\"hljs-number\">10</span>).<span class=\"hljs-title hljs-function\">keys</span>()].<span class=\"hljs-title hljs-function\">sort</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-number\">0.5</span> – <span class=\"hljs-title hljs-class\">Math</span>.<span class=\"hljs-title hljs-function\">random</span>())\n</code></pre>\n<p>可以拆成前後兩段程式碼：</p>\n<ol>\n<li>產生 0 ~ N 的陣列數組</li>\n<li>採用 shuffle 排序</li>\n</ol>\n<p>由於記憶中只剩下效率很差的泡泡排序，想說這樣的方式應該會導致數組無法穩定，一直在檢查吧？</p>\n<p>雖然理解瀏覽器不會採用 O(n^2) 的算法，但對各家瀏覽器採用的排序方式有點好奇，因此在網路上搜索一番：</p>\n<ul>\n<li>firefox - merge sort</li>\n<li>chrome - tim sort</li>\n</ul>\n<p>經過一番網海搜索，發現火狐採用的合併排序會導致結果不太亂，例如這是在火狐連續跑 5 次的結果：</p>\n<pre><code class=\"hljs language-js\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">9</span>][(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">7</span>)][\n  (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">9</span>)\n][(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">4</span>)][(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">9</span>)];\n</code></pre>\n<p>可以看出初始陣列最左邊的 0 與右邊的 9，幾乎依舊分別留在陣列的前後段。</p>\n<p>相對於 chrome 的連續跑五次的結果比較散亂：</p>\n<pre><code class=\"hljs language-js\">[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>][(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">4</span>)][\n  (<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">8</span>)\n][(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>)][(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">0</span>)];\n</code></pre>\n<p>如未來找到更有趣的亂數產生算法會繼續補充在文章內。</p>\n<ul>\n<li>\n<p>JavaScript 的 shuffle 演算法（發亂數不重複）https://kelunyang.wordpress.com/2009/04/01/javascript%E7%9A%84poker%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E7%99%BC%E4%BA%82%E6%95%B8%E4%B8%8D%E9%87%8D%E8%A4%87%EF%BC%89/</p>\n</li>\n<li>\n<p>從 Array 的 sort 方法，聊到各瀏覽器的實作 https://medium.com/@realdennis/javascript-%E5%BE%9Earray%E7%9A%84sort%E6%96%B9%E6%B3%95-%E8%81%8A%E5%88%B0%E5%90%84%E5%AE%B6%E7%80%8F%E8%A6%BD%E5%99%A8%E7%9A%84%E5%AF%A6%E4%BD%9C%E7%AE%97%E6%B3%95-c23a335b1b80</p>\n</li>\n<li>\n<p>合併排序法 http://alrightchiu.github.io/SecondRound/comparison-sort-merge-sorthe-bing-pai-xu-fa.html</p>\n</li>\n<li>\n<p>建立 1 ~ N 的數組陣列 https://stackoverflow.com/questions/3746725/how-to-create-an-array-containing-1-n</p>\n</li>\n</ul>"}},"__N_SSG":true}