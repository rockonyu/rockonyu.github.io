{"pageProps":{"post":{"title":"JS Ninja: 6. Prototype","slug":"js-ninja-6-prototype","content":"<p>簡單的筆記與紀錄額外參考，原作：<a href=\"https://www.books.com.tw/products/0010701459\" target=\"_blank\">忍者：JavaScript  開發技巧探秘</a></p>\n<h2>7.1 瞭解原型</h2>\n<p>透過原型，物件可以存取屬於其他物件的屬性。\n當存取物件所沒有的屬性時，會在物件原型裡搜索該屬性。</p>\n<pre><code class=\"language-JS\">const yoshi = { skulk: true };\nconst hattori = { sneak: true };\n\nObject.setPrototypeOf(yoshi, hattori);\n</code></pre>\n<h2>7.2 物件建構與原型</h2>\n<pre><code class=\"language-JS\">function Ninja(){}\nNinja.prototype.swingSword = function(){\n    return true;\n}\n</code></pre>\n<p>使用 <code>new</code> 運算子呼叫，會建立一個全新的物件，而 <code>swingSword</code> 函式會在實例化的物件間共用。\n若將方法定義在 <code>Ninja</code> 函式內，代表每個實例化的物件都各自保有方法定義。\n每個函式的原型物件都有一個 <code>constructor</code> 屬性，會參照到建構器函式。</p>\n<pre><code class=\"language-JS\">function Ninja(){}\n\nconst ninja = new Ninja();\nconst ninja2 = new ninja.constructor();\n</code></pre>\n<h2>7.3 實現物件繼承</h2>\n<pre><code class=\"language-JS\">function Person(){}\nPerson.prototype.dance = function(){};\n\nfunction Ninja(){}\nNinja.prototype = new Person();\n\nvar ninja = new Ninja();\n\nninja.constructor === Person\n</code></pre>\n<p>解決 <code>constructor</code> 屬性的問題</p>\n<pre><code class=\"language-JS\">// 新增一個不可列舉的 constructor 屬性並指回 Ninja\nObject.defineProperty(Ninja.prototype, \"constructor\", {\n    enumerable: false,\n    value Ninja,\n    writable: true\n});\n\nninja.constructor === Ninja\n</code></pre>\n<p><code>instanceof</code> 運算子會檢查 <code>Ninja</code> 函式目前的原型，是否出現在 <code>ninja</code> 物件實例的原型串鏈上。</p>\n<h2>7.4 在 ES6 裡使用 JavaScript 的類別</h2>\n<pre><code class=\"language-JS\">class Person {\n    constructor(name) {\n        this.name = name;\n    }\n\n    dance() {\n        return true;\n    }\n}\n\n// 使用 extends 關鍵字來繼承其他類別\nclass Ninja extends Person {\n    constructor(name, weapon) {\n        super(name);\n        this.weapon = weapon;\n    }\n\n    wieldWeapon() {\n        return true;\n    }\n}\n</code></pre>\n<h1>7.5 小結</h1>\n"}},"__N_SSG":true}