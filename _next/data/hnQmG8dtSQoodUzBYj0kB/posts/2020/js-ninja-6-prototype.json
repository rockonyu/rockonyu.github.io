{"pageProps":{"post":{"title":"JS Ninja: 6. Prototype","date":"2020-08-30T00:00:00.000Z","slug":"2020/js-ninja-6-prototype","content":"<p>簡單的筆記與紀錄額外參考，原作：忍者：JavaScript  開發技巧探秘</p>\n<h2>7.1 瞭解原型</h2>\n<p>透過原型，物件可以存取屬於其他物件的屬性。\n當存取物件所沒有的屬性時，會在物件原型裡搜索該屬性。</p>\n<pre><code>const yoshi = { skulk: true };\nconst hattori = { sneak: true };\n\nObject.setPrototypeOf(yoshi, hattori);\n</code></pre>\n<h2>7.2 物件建構與原型</h2>\n<pre><code>function Ninja(){}\nNinja.prototype.swingSword = function(){\n    return true;\n}\n</code></pre>\n<p>使用 <code>new</code> 運算子呼叫，會建立一個全新的物件，而 <code>swingSword</code> 函式會在實例化的物件間共用。\n若將方法定義在 <code>Ninja</code> 函式內，代表每個實例化的物件都各自保有方法定義。\n每個函式的原型物件都有一個 <code>constructor</code> 屬性，會參照到建構器函式。</p>\n<pre><code>function Ninja(){}\n\nconst ninja = new Ninja();\nconst ninja2 = new ninja.constructor();\n</code></pre>\n<h2>7.3 實現物件繼承</h2>\n<pre><code>function Person(){}\nPerson.prototype.dance = function(){};\n\nfunction Ninja(){}\nNinja.prototype = new Person();\n\nvar ninja = new Ninja();\n\nninja.constructor === Person\n</code></pre>\n<p>解決 <code>constructor</code> 屬性的問題</p>\n<pre><code>// 新增一個不可列舉的 constructor 屬性並指回 Ninja\nObject.defineProperty(Ninja.prototype, \"constructor\", {\n    enumerable: false,\n    value Ninja,\n    writable: true\n});\n\nninja.constructor === Ninja\n</code></pre>\n<p><code>instanceof</code> 運算子會檢查 <code>Ninja</code> 函式目前的原型，是否出現在 <code>ninja</code> 物件實例的原型串鏈上。</p>\n<h2>7.4 在 ES6 裡使用 JavaScript 的類別</h2>\n<pre><code>class Person {\n    constructor(name) {\n        this.name = name;\n    }\n\n    dance() {\n        return true;\n    }\n}\n\n// 使用 extends 關鍵字來繼承其他類別\nclass Ninja extends Person {\n    constructor(name, weapon) {\n        super(name);\n        this.weapon = weapon;\n    }\n\n    wieldWeapon() {\n        return true;\n    }\n}\n</code></pre>\n<h1>7.5 小結</h1>\n"}},"__N_SSG":true}